//======================================================
// Clock Divider: 100 MHz → 10 MHz (Divide by 10)
// Generates a 10 MHz clock with ~50% duty cycle
//======================================================

module clk_div_10 (
    input  wire clk_in,    // 100 MHz clock input
    input  wire rst_n,     // Active-low asynchronous reset
    output reg  clk_out    // 10 MHz clock output
);

    reg [2:0] cnt;         // Counter (counts 0→4 for half period)

    always @(posedge clk_in or negedge rst_n) begin
        if (!rst_n) begin
            cnt     <= 3'd0;
            clk_out <= 1'b0;
        end else begin
            if (cnt == 3'd4) begin
                cnt     <= 3'd0;
                clk_out <= ~clk_out; // Toggle every 5 input cycles
            end else begin
                cnt <= cnt + 3'd1;
            end
        end
    end

endmodule

///////////////////////////////////////////////////////////////
//======================================================
// Testbench for clk_div_10
// 100 MHz stimulus → 10 MHz output verification
//======================================================

`timescale 1ns/1ps

module tb_clk_div_10;

    reg  clk_in;
    reg  rst_n;
    wire clk_out;

    // DUT instantiation
    clk_div_10 uut (
        .clk_in (clk_in),
        .rst_n  (rst_n),
        .clk_out(clk_out)
    );

    // Generate 100 MHz clock (period = 10 ns)
    initial begin
        clk_in = 1'b0;
        forever #5 clk_in = ~clk_in; // Toggle every 5 ns
    end

    // Test stimulus
    initial begin
        rst_n = 1'b0;
        repeat(5) @(posedge clk_in); // Hold reset for a few cycles
        rst_n = 1'b1;

        #200; // Run simulation long enough to observe clk_out
        $stop;
    end

endmodule
