//======================================================
// Moore FSM conversion (Outputs depend only on state)
//======================================================

module fsm_moore (
    input  wire clk,       // System clock
    input  wire rst_n,     // Active-low reset
    input  wire din,       // External input
    output reg  dout       // Moore output (stable)
);

    //==================================================
    // State Encoding (Binary representation)
    //==================================================
    parameter S0  = 2'b00;  // Output = 0
    parameter S1  = 2'b01;  // Output = 0
    parameter S2  = 2'b10;  // Output = 1 (transitioned S1 with din=1)

    reg [1:0] state, next_state;

    //==================================================
    // 1) State Register (Sequential)
    //==================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= S0;          // Reset to initial state
        else
            state <= next_state;
    end

    //==================================================
    // 2) Next State Logic (Combinational)
    //==================================================
    always @(*) begin
        case (state)

            S0: begin
                if (din)
                    next_state = S1;
                else
                    next_state = S0;
            end

            S1: begin
                if (din)
                    next_state = S2;
                else
                    next_state = S1;
            end

            S2: begin
                if (din)
                    next_state = S0;
                else
                    next_state = S2;
            end

            default: next_state = S0;

        endcase
    end

    //==================================================
    // 3) Moore Output Logic (Combinational)
    //==================================================
    always @(*) begin
        case (state)
            S0: dout = 1'b0;
            S1: dout = 1'b0;
            S2: dout = 1'b1;   // Only this state outputs 1
            default: dout = 1'b0;
        endcase
    end

endmodule

///////////////////////////////

//======================================================
// Testbench for Moore FSM
// Stimulus applied on clock edges
//======================================================

`timescale 1ns/1ps

module tb_fsm_moore;

    reg  clk;
    reg  rst_n;
    reg  din;
    wire dout;

    // DUT instantiation
    fsm_moore dut (
        .clk  (clk),
        .rst_n(rst_n),
        .din  (din),
        .dout (dout)
    );

    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end

    // Stimulus generation synchronized to clock edges
    initial begin
        rst_n = 0;
        din   = 0;
        repeat (3) @(posedge clk);  // reset active for 3 cycles

        rst_n = 1;

        // Apply test vector: Synchronous toggling of din
        @(posedge clk) din = 1;
        @(posedge clk) din = 0;
        @(posedge clk) din = 1;
        @(posedge clk) din = 1;
        @(posedge clk) din = 0;
        @(posedge clk) din = 1;
        @(posedge clk) din = 0;
        @(posedge clk) din = 1;

        repeat (3) @(posedge clk);
        $finish;
    end


endmodule

